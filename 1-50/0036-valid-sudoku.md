# LeetCode 第 36 号问题：有效的数独

**难度中等**

### 题目描述

判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。

数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。
![](/Animation/0036-valid-sudoku.png)
上图是一个部分填充的有效的数独。
数独部分空格内已填入了数字，空白格用 '.' 表示。


**示例 1:**

```
[
  ["5","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: true
```

**示例 2:**

```
[
  ["8","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: false
解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。
     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
```

### 题目解析

## 方法一：递归
## 方法二：位运算优化
**思路与算法**
数 b 的二进制表示的第 i 位（从低到高，最低位为第 0 位）为 1，当且仅当数字 i+1 已经出现过。例如当 b 的二进制表示为 (011000100)
时，就表示数字 3，7，8 已经出现过
-- 对于第 i 行第 j 列的位置，line[i] | column[j] |block[i/3][j/3]中第 k 位为 1，表示该位置不能填入数字 k+1（因为已经出现过），
其中 |表示按位或运算。如果我们对这个值进行 ∼ 按位取反运算，那么第 k 位为 1 就表示该位置可以填入数字 k+1，我们就可以通过寻找 1 
来进行枚举。由于在进行按位取反运算后，这个数的高位也全部变成了 1，而这是我们不应当枚举到的，
因此我们需要将这个数和 (111111111)进行按位与运算 &，将所有无关的位置为 0；
-- 我们可以使用按位异或运算∧，将第 i 位从 0 变为 1，或从 1 变为 0。具体地，与数 1 << i 进行按位异或运算即可，其中 << 表示左移运算；
-- 我们可以用 b &(-b) 得到 b 二进制表示中最低位的 1，这是因为 (-b) 在计算机中以补码的形式存储，它等于 ∼b+1。bb 如果和 ∼b 进行按位与运算，
那么会得到 0，但是当 ∼b 增加 11 之后，最低位的连续的 1 都变为 0，而最低位的 0 变为 1，对应到 b 中即为最低位的 1，
因此当 b 和∼b+1 进行按位与运算时，只有最低位的 1 会被保留
-- 当我们得到这个最低位的 1 时，我们可以通过一些语言自带的函数得到这个最低位的 1 究竟是第几位（即 i 值），具体可以参考下面的代码
-- 我们可以用 b 和最低位的 1 进行按位异或运算，就可以将其从 b 中去除，这样就可以枚举下一个 1。同样地，
我们也可以用 b 和 b−1 进行按位与运算达到相同的效果，读者可以自行尝试推导

实际上，方法二中整体的递归 + 回溯的框架与方法一是一致的。不同的仅仅是我们将一个数组「压缩」成了一个数而已




### 代码实现

```php
//时间复杂度： O(1)
//空间复杂度： O(1)
class Solution
{

    /**
     * @param String[][] $board
     * @return Boolean
     */
    function isValidSudoku($board)
    {
        $row = $columns = $boxes = [];
        for ($i = 0; $i < 9; $i++) {
            for ($j = 0; $j < 9; $j++) {
                $num = $board[$i][$j];
                if ($num != '.') {
                    $box_index = floor($i / 3) * 3 + floor($j / 3);

                    if (++$row[$i][$num] > 1) {
                        echo 'row';
                        return false;
                    }
                    if (++$columns[$j][$num] > 1) {
                        echo 'columns';
                        return false;
                    }
                    if (++$boxes[$box_index][$num] > 1) {
                        echo 'boxes';

                        return false;
                    }
                }
            }
        }
        return true;
    }
}
```

